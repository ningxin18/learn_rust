//1、指针是一个包含内存地址的变量。这个地址指向一些其它的数据。
//智能指针是一类数据结构，它们表现类似于指针，但是也拥有额外的元数据，最明显的，它们拥有一个引用计数。引用计数记录智能指针总共有多少个所有者，并且当没有任何所有者时清除数据。
//普通引用和智能指针的一个额外区别是：引用只是只借用数据的指针，而智能指针则是拥有它们指向的数据。
//
//2、智能指针通常使用结构体实现。智能指针区别于常规结构体的显著特征在于其实现了 Deref 和 Drop trait。
//（1）Deref trait 允许智能指针结构体实例表现的像引用一样，这样就可以编写即用于引用，又用于智能指针的代码。
//（2）Drop trait 允许我们自定义当智能指针离开作用域时执行的代码。
//
//3、几个标准库中的智能指针：
//Box，用于在堆上分配；
//Rc，一个引用计数类型，其数据可以有多个所有者；
//Ref 和 RefMut，通过 RefCell<T 访问>，一个在运行时而不是在编译时执行借用规则的类型


//1、最简单最直接的智能指针是 box，其类型为 Box。box 允许将值放在堆上而不是栈上，留着栈上的则是指向堆数据的指针。除了数据被存储在堆上外，box 没有任何性能损失。
//2、box 适合用于如下场景：
//当有一个在编译时未知大小的类型，而又需要再确切大小的上下文中使用这个类型值的时候；
// （举例子：在一个list环境下，存放数据，但是每个元素的大小在编译时又不确定）
//当有大量数据并希望在确保数据不被拷贝的情况下转移所有权的时候；
//当希望拥有一个值并只关心它的类型是否实现了特定 trait 而不是其具体类型时。

//3、使用 Box 在堆上存储数据：
//enum List {
//    Cons(i32, List),
//    Nil,
//}

enum List {
    Cons(i32, Box<List>),
    Nil,
}

fn main() {
    let b = Box::new(5); //b存储在栈上，5存储在堆上，b指向5所在的内存
    println!("b = {}", b);

    use List::Cons;
    use List::Nil;
//    let list = Cons(1, Cons(2, Cons(3, Nil)));
    let list = Cons(1,
                    Box::new(Cons(2,
                        Box::new(Cons(3,
                            Box::new(Nil))))));

}

